% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sample_mcmc.R
\name{slice_sampler}
\alias{slice_sampler}
\title{MCMC sampling designed for binary factor analysis (unknown number of factors)}
\usage{
slice_sampler(dat, model_options, mcmc_options)
}
\arguments{
\item{dat}{multivariate binary data (row for observations and column for dimensions4)}

\item{model_options}{Specifying assumed model options:
\itemize{
\item \code{n} The number of subjects.
\item \code{t_max} The maximum (guessed) number of clusters in the data during
posterior inference
\item \code{m_max} For a model with pre-specified number of factors, \code{m_max};
In an infinite factor model with unknown number of factors, \code{m_max} is
the maximum (guessed) number of factors during the posterior inference (see \code{\link{slice_sampler}});
one can increase this number if this pacakge recommends so;
\item \code{a_theta, a_psi} hyperparameters for true and false positive rates;
a_theta and a_psi are both a vector of length two.
\item \code{a_alpha, b_alpha} Only for infinite factor model  -
Gamma hyperparameter for the hyperprior on \code{alpha}. (See \code{\link{slice_sampler}})
\item \code{log_v} The charaster string representing the prior
distribution for the number of true clusters, e.g.,
\code{"function(k) {log(0.1) + (k-1)*log(0.9)}"}. It is usually pre-computed log of the coefficients in Mixture of Finite Mixtures
(Miller and Harrison, 2017, JASA). Use this code:
\code{coefficients(eval(parse(text=model_options0$log_pk)),
model_options0$gamma,
model_options0$n,
model_options0$t_max+1)}
}
The following are used if one needs to prefix a few unnown parameters to
their respective true or other values
\itemize{
\item \code{Q} Q matrix
\item \code{theta} a vector of true positive rates
\item \code{psi} a vector of false positive rates
\item \code{p} a vector of machine prevalences
\item \code{alpha} For pre-specified number of factors, the hyperparameter
for \code{Beta(alpha/m_max,1)} (can set to \code{m_max}); For infinite factor model, the hyperparameter
for IBP (can set to 1).
}
options for specifying data, sample size, max cluster number,
coefficients in MFM (Miller and Harrison 2017 JASA), gamma parameter in the MFM
Dirchlet prior, number of intermediate Gibbs scan to arrive at the launch state,
and other hyperparamter specification if needed, n_total for total number of
mcmc iterations and n_keep for the number of samples kept for posterior inference.
Note that the options involve other parameters for sampling hyperparameters such as
alpha in the Indian Buffet Process.}

\item{mcmc_options}{Options for MCMC sampling:
\itemize{
\item \code{n_total} total number of MCMC iterations
\item \code{n_keep} number of iterations kept
\item \code{n_split} the number of restricted Gibbs scan to arrive at a launch state;
see \link{restricted_gibbs}
\item \code{print_mod} print machine usage profiles for all clusters and plot
the current Q matrix.
\item \code{constrained} update the Q matrix with identifiability constraints (if \code{TRUE}); otherwise, set to \code{FALSE}.
\item \code{block_update_H} update rows of H (if \code{TRUE}) or not
(if \code{NULL} or FALSE - must be so for \code{\link{slice_sampler}}). Then no constraints
about identifiability is imposed upon Q at any iterations.
\item \code{block_update_Q} update columns of Q (if \code{TRUE}) or not
(if \code{NULL} or FALSE - must be so for \code{\link{slice_sampler}}). Then no constraints
about identifiability is imposed upon Q at any iterations.
}}
}
\value{
posterior samples for quantities of interest. It is a list comprised of the following elements
\itemize{
\item \code{t_samp}
\item \code{z_samp}
\item \code{N_samp}
\item \code{keepers} indices of MCMC samples kept for inference;
\item \code{H_star_samp}
\item \code{alpha_samp}
\item \code{m_plus_samp} This is unique to slice_sampler
\item \code{m0_samp} This is unique to slice_sampler
} The following are recorded if they are not fixed in a priori:
\itemize{
\item \code{Q_samp}
\item \code{theta_samp}
\item \code{psi_samp}
\item \code{p_samp}
}
}
\description{
This function performs MCMC sampling with user-specified options.
NB: 1) add flexibility to specify other parameters as fixed.
2) sample component-specific
parameters.
3) sample other model parameters.
4) add timing and printing functionality.
5) add posterior summary functions.
6) merge machines
7) record row and colum merge mappings
}
\examples{
#\dontrun{
rm(list=ls())
library(rewind)
library(matrixStats)
library(ars)
# ---------------------------------------------
# SIMULATIONS
# 1. setting m_plus_init = 10 gets the true factors down to three.

# color palette for heatmaps:
YlGnBu5   <- c('#ffffd9','#c7e9b4','#41b6c4','#225ea8','#081d58',"#092d94")
hmcols    <- colorRampPalette(YlGnBu5)(256)


# simulate data:
L0 <- 100
options_sim0  <- list(N = 50,  # sample size.
                      M = 3,   # true number of machines.
                      L = L0,   # number of antibody landmarks.
                      K = 2^3,    # number of true components.,
                      theta = rep(0.9,L0), # true positive rates
                      psi   = rep(0.1,L0), # false positive rates
                      alpha1 = 1 # half of the people have the first machine.
)

image(simulate_data(options_sim0,SETSEED = TRUE)$datmat,col=hmcols)
simu     <- simulate_data(options_sim0, SETSEED=TRUE)
simu_dat <- simu$datmat

#
# specifying options
#

# check BayesianMixtures.jl for how options were set.

# model options:
model_options0 <- list(
  n   = nrow(simu_dat),
  t_max  = 40,
  m_max  = 100,
  b  = 1, # Dirichlet hyperparameter; in the functions above, we used "b" -
          # also can be called "gamma".
  #Q  = simu$Q,
  a_theta = c(9,1),
  a_psi   = c(1,9),
  a_alpha = 1, # hyperparameter for IBP alpha.
  b_alpha = 1,
  #theta = options_sim0$theta,
  #psi   = options_sim0$psi,
  #alpha   = options_sim0$M,
  #p_both      = rep(0.5,3),#,c(0.5,0.5^2,0.5^3,0.5^4,0.5^5)
  log_pk = "function(k) {log(0.1) + (k-1)*log(0.9)}"# Geometric(0.1).
                                   #Prior for the number of components.
)

# pre-compute the log of coefficients in MFM:
model_options0$log_v<-mfm_coefficients(eval(parse(text=model_options0$log_pk)),
                                         model_options0$gamma,
                                         model_options0$n,
                                         model_options0$t_max+1)
# mcmc options:
mcmc_options0 <- list(
  n_total = 200,
  n_keep  = 200,
  n_split = 5,
  print_mod = 10,
  m_plus_init = 10,
  m0_init = 0,
  constrained = TRUE,
  block_update_H = TRUE,# NULL is also okay - because the conditional
                        # distribution of z_jm depends on p_min^+,
                        # it is not obvious how to do block updating.
  block_update_Q = !TRUE, # NULL is also okay - slice_sampler() do not
                          # use block updating
                         # of Q, because truncation level m_both can
                          # be very large, using block updating is very
                          # expensive (2^m_both
                          # multivariate binary patterns)
  hmcols = hmcols
)


#
# run posterior algorithm for simulated data:
#

out <- slice_sampler(simu_dat,model_options0,mcmc_options0)

#
# Posterior summaries:
#

YlGnBu5   <- c('#ffffd9','#c7e9b4','#41b6c4','#225ea8','#081d58',"#092d94")
hmcols    <- colorRampPalette(YlGnBu5)(256)


# comparing true Q to sampled Q:
ind_post_mode <- mcmc_options0$n_total#which.max(table(pats))
#pdf("diagnosticsQ.pdf",width=12,height=6)
par(mfrow=c(1,4))
image(simu$datmat,main="Data",col=hmcols)
image(simu$xi,main="True presence/absence of proteins)",col=hmcols)
image(order_mat_byrow(simu$Q)$res,main="True Q (ordered)",col=hmcols)
Q_merged <- out$Q_merge_samp[,,ind_post_mode]
image(order_mat_byrow(Q_merged[rowSums(Q_merged)!=0,,drop=FALSE])$res,
      main="Sampled Q (merged & ordered)",col=hmcols)
#dev.off()

# co-clustering:
comat <- coclust_mat(nrow(simu_dat),out$z_samp,mcmc_options0$n_keep)
image(1:options_sim0$N,1:options_sim0$N, comat,
      xlab="Subjects",ylab="Subjects",col=hmcols,main="co-clustering")
for (k in 1:options_sim0$K){
  abline(h=cumsum(rle(simu$Z)$lengths)[k]+0.5,lty=2)
  abline(v=cumsum(rle(simu$Z)$lengths)[k]+0.5,lty=2)
}

#}
}
